<script>
  let canvas;
  let context;
  let player;
  let enemies;
  let projectiles;
  let score;
  let highScore = 0;

  window.onload = function() {
    canvas = document.getElementById('canvas');
    context = canvas.getContext('2d');
    initializeGame();

    window.addEventListener('keydown', keyDownHandler);
    window.addEventListener('keyup', keyUpHandler);

    setInterval(()=>requestAnimationFrame(update), 1000/60);

    setInterval(()=>requestAnimationFrame(spawnEnemy), 1000);
  }

  function initializeGame() {
    score = 0;
    document.getElementById('scoreLabel').innerHTML = score;
    player = {
      x: canvas.width/2,
      y: canvas.height/2,
      size: 20,
      speed: 10,
      topSpeed: 10,
      vx: 0,
      vy: 0,
      projectileSize: 5,
      projectileSpeed: 5,
    };
    enemies = [];
    projectiles = [];
  }

  function getRandomNumber(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function spawnEnemy() {
    enemies.push({
      x: getRandomNumber(0, canvas.width),
      y: -10,
      vy: getRandomNumber(2, 7),
      size: getRandomNumber(10, 40),
    });
  }

  function update() {
    context.fillStyle = 'black';
    context.fillRect(0,0,canvas.width,canvas.height);

    // Clean up enemies
    enemies = enemies.filter(function(enemy) { 
      if (enemy.y <= canvas.height) {
        return true;
      }
    });

    // Clean up projectiles
    projectiles = projectiles.filter(function(projectile) { 
      if (projectile.y >= 0) {
        return true;
      }
    });

    // Move and draw projectiles
    context.fillStyle = 'blue';
    for (const projectile of projectiles) {
      projectile.y -= player.projectileSpeed;
      context.beginPath();
      context.arc(projectile.x, projectile.y, projectile.size, 0, 2*Math.PI);
      context.closePath();
      context.fill();
    }

    // Player
    if (player.x + player.vx > 0 && player.x + player.vx < canvas.width) {
      player.x += player.vx;
    }
    if (player.y + player.vy > 0 && player.y + player.vy < canvas.height) {
      player.y += player.vy;
    }

    context.fillStyle = 'gray';
    context.beginPath();
    context.arc(player.x, player.y, player.size, 0, 2*Math.PI);
    context.closePath();
    context.fill();
    context.fillStyle = 'white';
    context.beginPath();
    context.moveTo(player.x, player.y - player.size);
    context.lineTo(player.x - player.size, player.y + player.size);
    context.lineTo(player.x + player.size, player.y + player.size);
    context.closePath();
    context.fill();

    // Move and draw enemies
    context.fillStyle = 'red';
    for (let enemyIndex = enemies.length -1; enemyIndex >= 0; enemyIndex--) {
      const enemy = enemies[enemyIndex];
      enemy.y += enemy.vy;

      // check for collision of player
      if (hasCollided(player, enemy)) {
        context.fillStyle = 'red';
        context.fillRect(0,0,canvas.width,canvas.height);

        initializeGame();
        return;
      }

      let hasBeenDestroyed = false;
      // check for collision of projectile
      for (let projIndex = projectiles.length -1; projIndex >= 0; projIndex--) {
        const projectile = projectiles[projIndex];
        if (hasCollided(projectile, enemy)) {
          // Remove enemy
          enemies.splice(enemyIndex, 1);
          // Remove projectile
          projectiles.splice(projIndex, 1);
          hasBeenDestroyed = true;
          score++;
          document.getElementById('scoreLabel').innerHTML = score;
          if (score > highScore) {
            highScore = score;
            document.getElementById('highScoreLabel').innerHTML = highScore;
          }
          break;
        }
      }

      if (!hasBeenDestroyed) {
        context.beginPath();
        context.arc(enemy.x, enemy.y, enemy.size, 0, 2*Math.PI);
        context.closePath();
        context.fill();
      }
    }
  }

  function hasCollided(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx*dx + dy*dy);
    return distance < (obj1.size + obj2.size);
  }

  function keyDownHandler(event) {
    switch (event.keyCode) {
      case 32: // Space
        projectiles.push({
          x: player.x,
          y: player.y,
          size: player.projectileSize,
        });
        break;
      case 87: // W
        if (player.vy > -player.topSpeed) {
          player.vy -= player.speed;
        }
        break;
      case 65: // A
        if (player.vx > -player.topSpeed) {
          player.vx -= player.speed;
        }
        break;
      case 83: // S
        if (player.vy < player.topSpeed) {
          player.vy += player.speed;
        }
        break;
      case 68: // D
        if (player.vx < player.topSpeed) {
          player.vx += player.speed;
        }
        break;
    }
  }

  function keyUpHandler(event) {
    switch (event.keyCode) {
      case 87: // W
        player.vy = 0;
        break;
      case 65: // A
        player.vx = 0;
        break;
      case 83: // S
        player.vy = 0;
        break;
      case 68: // D
        player.vx = 0;
        break;
    }
  }
</script>
<style type="text/css">
  label {
    display: inlineBlock;
  }
</style>
<div>
<label>
  Score:
  <label id="scoreLabel"></label>
</label>
<label style="padding-left: 20px">
  High Score:
  <label id="highScoreLabel">0</label>
</label>
</div>
<canvas id="canvas" width=640 height=480></canvas>
<div>WASD to move, space to shoot</div>