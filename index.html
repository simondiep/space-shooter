<script>
  let canvas;
  let context;
  let player;
  let enemies;
  let projectiles;
  let score;
  let highScore = 0;

  window.onload = function() {
    canvas = document.getElementById('canvas');
    context = canvas.getContext('2d');
    initializeGame();

    window.addEventListener('keydown', keyDownHandler);
    window.addEventListener('keyup', keyUpHandler);

    setInterval(()=>requestAnimationFrame(update), 1000/60);

    setInterval(()=>requestAnimationFrame(spawnEnemy), 1000);
  }

  function initializeGame() {
    score = 0;
    document.getElementById('scoreLabel').innerHTML = score;
    document.getElementById('shot-type-single').checked = true;
    player = {
      x: canvas.width/2,
      y: canvas.height - 30,
      size: 20,
      speed: 2,
      topSpeed: 10,
      directionsPressed: {
        UP: false,
        DOWN: false,
        LEFT: false,
        RIGHT: false,
      },
      vx: 0,
      vy: 0,
      projectileSize: 5,
      projectileSpeed: 5,
      shotType: 'single',
    };
    enemies = [];
    projectiles = [];
  }

  function getRandomNumber(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function spawnEnemy() {
    enemies.push({
      x: getRandomNumber(0, canvas.width),
      y: -10,
      vy: getRandomNumber(2, 7),
      size: getRandomNumber(10, 40),
    });
  }

  function update() {
    context.fillStyle = 'black';
    context.fillRect(0,0,canvas.width,canvas.height);

    // Clean up enemies
    enemies = enemies.filter(function(enemy) { 
      if (enemy.y <= canvas.height) {
        return true;
      }
    });

    // Clean up projectiles
    projectiles = projectiles.filter(function(projectile) { 
      if (projectile.y >= 0) {
        return true;
      }
    });

    // Move and draw projectiles
    context.fillStyle = 'blue';
    for (const projectile of projectiles) {
      projectile.x += projectile.vx;
      projectile.y += projectile.vy;
      context.beginPath();
      context.arc(projectile.x, projectile.y, projectile.size, 0, 2*Math.PI);
      context.closePath();
      context.fill();
    }

    // Player Movement
    if (player.directionsPressed.UP && player.vy > -player.topSpeed) {
      player.vy -= player.speed;
    }
    if (player.directionsPressed.DOWN && player.vy < player.topSpeed) {
      player.vy += player.speed;
    }
    if (player.directionsPressed.LEFT && player.vx > -player.topSpeed) {
      player.vx -= player.speed;
    }
    if (player.directionsPressed.RIGHT && player.vx < player.topSpeed) {
      player.vx += player.speed;
    }

    if (!player.directionsPressed.UP && !player.directionsPressed.DOWN) {
      player.vy = 0;
    }
    if (!player.directionsPressed.LEFT && !player.directionsPressed.RIGHT) {
      player.vx = 0;
    }

    if (player.x + player.vx > 0 && player.x + player.vx < canvas.width) {
      player.x += player.vx;
    }
    if (player.y + player.vy > 0 && player.y + player.vy < canvas.height) {
      player.y += player.vy;
    }

    // Draw player
    context.fillStyle = 'gray';
    context.beginPath();
    context.arc(player.x, player.y, player.size, 0, 2*Math.PI);
    context.closePath();
    context.fill();
    context.fillStyle = 'white';
    context.beginPath();
    context.moveTo(player.x, player.y - player.size);
    context.lineTo(player.x - player.size, player.y + player.size);
    context.lineTo(player.x + player.size, player.y + player.size);
    context.closePath();
    context.fill();

    // Move and draw enemies
    context.fillStyle = 'red';
    for (let enemyIndex = enemies.length -1; enemyIndex >= 0; enemyIndex--) {
      const enemy = enemies[enemyIndex];
      enemy.y += enemy.vy;

      // check for collision of player
      if (hasCollided(player, enemy)) {
        context.fillStyle = 'red';
        context.fillRect(0,0,canvas.width,canvas.height);

        initializeGame();
        return;
      }

      let hasBeenDestroyed = false;
      // check for collision of projectile
      for (let projIndex = projectiles.length -1; projIndex >= 0; projIndex--) {
        const projectile = projectiles[projIndex];
        if (hasCollided(projectile, enemy)) {
          // Remove enemy
          enemies.splice(enemyIndex, 1);
          // Remove projectile
          projectiles.splice(projIndex, 1);
          hasBeenDestroyed = true;
          score++;
          document.getElementById('scoreLabel').innerHTML = score;
          if (score > highScore) {
            highScore = score;
            document.getElementById('highScoreLabel').innerHTML = highScore;
          }
          break;
        }
      }

      if (!hasBeenDestroyed) {
        context.beginPath();
        context.arc(enemy.x, enemy.y, enemy.size, 0, 2*Math.PI);
        context.closePath();
        context.fill();
      }
    }
  }

  function hasCollided(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx*dx + dy*dy);
    return distance < (obj1.size + obj2.size);
  }

  function keyDownHandler(event) {
    switch (event.keyCode) {
      case 32: // Space
        event.preventDefault();
        switch (player.shotType) {
          case 'double':
            projectiles.push({
              x: player.x - player.size/2,
              y: player.y,
              vx: 0,
              vy: -player.projectileSpeed,
              size: player.projectileSize,
            });
            projectiles.push({
              x: player.x + player.size/2,
              y: player.y,
              vx: 0,
              vy: -player.projectileSpeed,
              size: player.projectileSize,
            });
            break;
          case 'ball':
            projectiles.push({
              x: player.x,
              y: player.y,
              vx: 0,
              vy: -player.projectileSpeed/2,
              size: player.projectileSize*4,
            });
            break;
          case 'laser':
            for (let i = 1; i <= 30; i++) {
              projectiles.push({
                x: player.x,
                y: player.y - i*10,
                vx: 0,
                vy: -player.projectileSpeed*10,
                size: player.projectileSize*2,
              });
            }
            break;
          case 'spread':
            projectiles.push({
              x: player.x - player.size/2,
              y: player.y,
              vx: -player.projectileSpeed/2,
              vy: -player.projectileSpeed,
              size: player.projectileSize,
            });
            projectiles.push({
              x: player.x,
              y: player.y,
              vx: 0,
              vy: -player.projectileSpeed,
              size: player.projectileSize,
            });
            projectiles.push({
              x: player.x + player.size/2,
              y: player.y,
              vx: player.projectileSpeed/2,
              vy: -player.projectileSpeed,
              size: player.projectileSize,
            });
            break;
          case 'side':
            projectiles.push({
              x: player.x,
              y: player.y,
              vx: -player.projectileSpeed,
              vy: 0,
              size: player.projectileSize,
            });
            projectiles.push({
              x: player.x,
              y: player.y,
              vx: player.projectileSpeed,
              vy: 0,
              size: player.projectileSize,
            });
            break;
          default:
            projectiles.push({
              x: player.x,
              y: player.y,
              vx: 0,
              vy: -player.projectileSpeed,
              size: player.projectileSize,
            });
        }
        break;
      case 87: // W
        player.directionsPressed.UP = true;
        break;
      case 65: // A
        player.directionsPressed.LEFT = true;
        break;
      case 83: // S
        player.directionsPressed.DOWN = true;
        break;
      case 68: // D
        player.directionsPressed.RIGHT = true;
        break;
    }
  }

  function keyUpHandler(event) {
    switch (event.keyCode) {
      case 87: // W
        player.directionsPressed.UP = false;
        break;
      case 65: // A
        player.directionsPressed.LEFT = false;
        break;
      case 83: // S
        player.directionsPressed.DOWN = false;
        break;
      case 68: // D
        player.directionsPressed.RIGHT = false;
        break;
    }
  }

  function onShotSelected(shotType) {
    player.shotType = shotType;
  }
</script>
<style type="text/css">
  label {
    display: inlineBlock;
  }
</style>
<div>
<label>
  Score:
  <label id="scoreLabel"></label>
</label>
<label style="padding-left: 20px">
  High Score:
  <label id="highScoreLabel">0</label>
</label>
</div>
<canvas id="canvas" width=640 height=480></canvas>
<fieldset>
  <legend>Select your Shot Type</legend>
  <div>
    <input type="radio" id="shot-type-single" name="shot-type" onclick="onShotSelected('single')" checked/>
    <label for="shot-type-single">Single</label>
    <input type="radio" id="shot-type-double" name="shot-type" onclick="onShotSelected('double')"/>
    <label for="shot-type-double">Double</label>
    <input type="radio" id="shot-type-spread" name="shot-type" onclick="onShotSelected('spread')"/>
    <label for="shot-type-spread">Spread</label>
    <input type="radio" id="shot-type-ball" name="shot-type" onclick="onShotSelected('ball')"/>
    <label for="shot-type-ball">Ball</label>
    <input type="radio" id="shot-type-laser" name="shot-type" onclick="onShotSelected('laser')"/>
    <label for="shot-type-laser">Laser</label>
    <input type="radio" id="shot-type-side" name="shot-type" onclick="onShotSelected('side')"/>
    <label for="shot-type-side">Side</label>
  </div>
</fieldset>
<div>WASD to move, space to shoot</div>